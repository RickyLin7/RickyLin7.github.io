<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>自顶向下-gRPC调用 - moontalk</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="MidoriFizz" /><meta name="description" content="RPC RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为" />






<meta name="generator" content="Hugo 0.91.2 with theme even" />


<link rel="canonical" href="https://blog.moontalk.top/post/top-down-grpc-call/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.698b45f22722579088fe87bfd0e2dd1ca078c05594c8d33ce7b82b5733f75032.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="自顶向下-gRPC调用" />
<meta property="og:description" content="RPC RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.moontalk.top/post/top-down-grpc-call/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-28T21:42:38+08:00" />
<meta property="article:modified_time" content="2021-12-28T21:42:38+08:00" />

<meta itemprop="name" content="自顶向下-gRPC调用">
<meta itemprop="description" content="RPC RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为"><meta itemprop="datePublished" content="2021-12-28T21:42:38+08:00" />
<meta itemprop="dateModified" content="2021-12-28T21:42:38+08:00" />
<meta itemprop="wordCount" content="3633">
<meta itemprop="keywords" content="自顶向下,gRPC,RPC," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="自顶向下-gRPC调用"/>
<meta name="twitter:description" content="RPC RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">MoonTalk</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">MoonTalk</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">自顶向下-gRPC调用</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-28 </span>
        <div class="post-category">
            <a href="/categories/%E7%BD%91%E7%BB%9C/"> 网络 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#rpc">RPC</a></li>
    <li><a href="#grpc">gRPC</a>
      <ul>
        <li><a href="#客户端">客户端</a></li>
        <li><a href="#数据编解码">数据编解码</a></li>
        <li><a href="#服务端">服务端</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="rpc">RPC</h2>
<p>RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为位置透明）。然而后来被证明把本地调用和远程调用当成一样来处理，是犯了方向性错误，这种透明的调用形式反而让程序员们认为通信是无成本的，从而被滥用，导致显著降低了分布式系统的性能。</p>
<p>首先，网络请求和本地函数调用非常不同：</p>
<ul>
<li>本地函数调用是可预测的，成功与否取决于参数控制；网络请求是不可预测的，请求或响应都有可能因为网络问题而丢失。</li>
<li>本地函数要么返回一个结果，要么抛出一个异常，或者永远不会返回（因为进入死循环或进程崩溃）；网络请求有另外一种可能的结果：因为超时导致返回时没有结果。</li>
<li>如果重试失败的网络请求，可能出现请求实际已经完成，只是响应丢失的情况。这种情况下，重试导致操作被执行了多次，而本地函数调用没有这样的问题。</li>
<li>每次执行本地函数调用的时间大致是相同的；网络请求则比函数调用要慢得多，且延迟也有很大的变化。</li>
<li>本地函数调用可以高效的将引用（指针）传递给本地内存中的对象；网络请求则需要将数据编码成可以通过网络发送的字节序列。</li>
</ul>
<p>以上这些因素都意味着让远程服务调用变得与本地函数调用一样是一件毫无意义的事。RPC 依赖网络通信，而网络有着不可靠、不安全、存在带宽限制、存在延迟等特点，所以 RPC 根本无法做到像 IPC 那样底层透明。因此，RPC 的定位应该是一种高层次的，或者说语言层次的模型（结合具体的业务场景，做网络上的取舍），而不是像 IPC 那样，是低层次，或者说系统层次的模型。</p>
<p>新一代的 RPC 框架基本明确了远程服务调用与本地函数调用不同的事实。例如：用 Futures 来封装可能失败的异步操作、支持流式响应、提供自动重试、提供服务发现等。</p>
<p>RPC 模型可以用下图来表示：</p>
<p><img src="/media/grpc@2x.png" alt="grpc@2x"></p>
<h2 id="grpc">gRPC</h2>
<p>gRPC 是一个 google 开源的高性能 RPC 框架，目前提供 C、Java 和 Go 语言版本，分别是：grpc、grpc-java、grpc-go。其中 C 版本支持 C、C++、C#、Node.js、Python、Ruby、 Objective-C 和 PHP。本文用 Go 语言版本 grpc-go 做原理分析。</p>
<p>下面我将对 grpc-go 官方的 <a href="https://github.com/grpc/grpc-go/tree/344b93a285883f2da713622d5064ad4b4512e63e/examples/helloworld">helloworld</a> 样例进行源码分析（因 gRPC 的代码比较复杂，所以仅展示逻辑调用关键部分代码），看看 gRPC 是如何实现 RPC 模型的。</p>
<p>目录结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">helloworld
├── greeter_client    
│   └── main.go
├── greeter_server
│   └── main.go
└── helloworld
    ├── helloworld.pb.go
    ├── helloworld.proto    
    └── helloworld_grpc.pb.go
</code></pre></td></tr></table>
</div>
</div><h3 id="客户端">客户端</h3>
<p>客户端业务逻辑主要分为三个步骤：</p>
<ol>
<li>创建连接</li>
<li>创建客户端实例</li>
<li>调用 RPC 接口</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// examples/helloworld/greeter_client/main.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建与服务端的连接，WithBlock() 会阻塞直到与服务端握手成功
</span><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
	<span class="c1">// 创建客户端实例
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewGreeterClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="c1">// 本地 RPC 方法调用
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">name</span><span class="p">})</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Greeting: %s&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">GetMessage</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>本地 RPC 方法调用最终会调用 <code>grpc-go/call.go</code> 文件中的 <code>invoke()</code> 函数。简单分析一下 <code>invoke()</code> 的逻辑：<code>newClientStream</code> 用来获取传输层 <code>Trasport</code> 并组合封装到 <code>ClientStream</code> 中返回，在这块会涉及负载均衡、超时控制、Encoding 以及 Stream 的处理，最主要的是获取一个连接给后续 RPC 调用传输使用。<code>SendMsg()</code> 会将 RPC 请求发送到服务端，但是并不会等待服务端收到数据，所以需要通过 <code>RecvMsg()</code> 同步响应，<code>RecvMsg()</code> 会一直阻塞直到 <code>HelloReply</code> 接收到消息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// examples/helloworld/helloworld/helloworld_grpc.pb.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">greeterClient</span><span class="p">)</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">HelloRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">HelloReply</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloReply</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/helloworld.Greeter/SayHello&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// call.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="数据编解码">数据编解码</h3>
<p>当我们需要把内存中的数据通过网络发送时，必须将其编码为某种自包含的字节序列（例如常见的 JSON 文档）。gRPC 采用的则是二进制编码 Protocol Buffers，相比于 MessagePack 这种 JSON 的二进制编码，最大的区别就是省略了字段名（类似的编码格式还有 Thrift），取而代之的是数字类型的字段标签（1、2和3），需要在模式（schema）中定义。</p>
<p>来看个简单的例子，这是一条 JSON 编码的样本记录（删除空白后需要占 81 个字节）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">{
    &#34;userName&#34;: &#34;Martin&#34;,
    &#34;favoriteNumber&#34;: 1337,
    &#34;interests&#34;: [&#34;daydreaming&#34;, &#34;hacking&#34;]
}
</code></pre></td></tr></table>
</div>
</div><p>然后通过 Protocol Buffers 模式定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">message Person {
    required string user_name       = 1;
    optional int64  favorite_number = 2;
    repeated string interests       = 3;
}
</code></pre></td></tr></table>
</div>
</div><p>最终生成的编码只占用 33 个字节，相当紧凑，具体编码分解如下图所示：</p>
<p><img src="/media/16410370775337.jpg" alt=""></p>
<p>客户端在发送请求时需要编码数据，然后接收响应时解码数据；服务端则在接收请求时解码数据，发送响应时编码数据。在我们当前这个 <a href="https://github.com/grpc/grpc-go/tree/344b93a285883f2da713622d5064ad4b4512e63e/examples/helloworld">helloworld</a> 样例中，编解码最终调用的是 <code>grpc-go/encoding/proto/proto.go</code> 文件中 <code>Marshal()</code> 和 <code>Unmarshal</code> 方法 ，具体的实现是在另一个包 <code>github.com/golang/protobuf/proto</code> 中，这里就不赘述了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// encoding/proto/proto.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">codec</span><span class="p">)</span> <span class="nf">Marshal</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">vv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.(</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to marshal, message is %T, want proto.Message&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">vv</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">codec</span><span class="p">)</span> <span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">vv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.(</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to unmarshal, message is %T, want proto.Message&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">vv</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="服务端">服务端</h3>
<p>服务端业务逻辑主要分为四个步骤：</p>
<ol>
<li>创建端口监听</li>
<li>创建服务端实例</li>
<li>注册服务</li>
<li>启动服务</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// examples/helloworld/greeter_server/main.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// 创建端口监听（监听 tcp 端口）
</span><span class="c1"></span>	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
	<span class="c1">// 创建服务端实例
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
	<span class="c1">// 注册服务（仅注册，并未真正开始服务）
</span><span class="c1"></span>	<span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterGreeterServer</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">server</span><span class="p">{})</span>
	<span class="c1">// 启动服务
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;failed to serve: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>RegisterGreeterServer</code> 是 <code>helloworld_grpc.pb.go</code> 生成的接口，调用了 <code>grpc-go/server.go</code> 的 <code>RegisterService()</code> 方法来注册当前的 service 实例及其功能接口实现。<code>Greeter_ServiceDesc</code> 则是由 pb 生成的 RPC 业务接口描述，具体的字段含义我已标注。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// examples/helloworld/helloworld/helloworld_grpc.pb.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RegisterGreeterServer</span><span class="p">(</span><span class="nx">s</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceRegistrar</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">GreeterServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Greeter_ServiceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Greeter_ServiceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;helloworld.Greeter&#34;</span><span class="p">,</span>  <span class="c1">// 服务名称
</span><span class="c1"></span>	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">GreeterServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>  <span class="c1">// 指向服务接口的指针。用于检查用户提供的实现是否满足接口要求
</span><span class="c1"></span>	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>  <span class="c1">// 一元（Unary）方法集合
</span><span class="c1"></span>		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;SayHello&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_Greeter_SayHello_Handler</span><span class="p">,</span>  <span class="c1">// 最终的 RPC 处理方法，在执行 RPC 方法的阶段会使用
</span><span class="c1"></span>		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>  <span class="c1">// 流式（Streaming）方法集合
</span><span class="c1"></span>	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;examples/helloworld/helloworld/helloworld.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，这里出现了两个名词“一元（Unary）”和“流式（Streaming）”，开一块区域简单说明一下。</p>
<p>gRPC 一共有四种传输模式：</p>
<ul>
<li>简单RPC：客户端发送一个单独的请求（Unary），并且接收服务端对这个请求的单独回复（Unary），类似普通的函数调用。</li>
<li>服务端流RPC：客户端发送一个单独的请求（Unary），服务端返回流式数据（Streaming），客户端读取流式数据直到EOF。gRPC保证每个调用中的信息排序。</li>
<li>客户端流RPC：客户端写入流式数据（Streaming），写入完成后等待服务端读取并返回单独的结果（Unary）。gRPC保证每个调用中的信息排序。</li>
<li>双向流RPC：客户端和服务端双方都使用读写流发送一系列消息。这两个流是独立运行的，因此客户端和服务器可以按照自己需要的顺序进行读写，例如，服务端可以在写响应之前等待接收所有客户端消息，或者可以先读取一条消息再写入一条消息，或其他一些读写组合。gRPC保证每个调用中的信息排序。</li>
</ul>
<p>很明显，我们这里的例子属于简单RPC传输模式，所以 <code>SayHello</code> 在一元（Unary）方法集合中。</p>
<p>好了，再回到我们的源码分析，<code>_Greeter_SayHello_Handler()</code> 也是由 pb 生成的方法。在其内部通过注册进来的 service 实例，对我们实现的业务函数 <code>SayHello()</code> 进行了调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// examples/helloworld/helloworld/helloworld_grpc.pb.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_Greeter_SayHello_Handler</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dec</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">interceptor</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">HelloRequest</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">dec</span><span class="p">(</span><span class="nx">in</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">interceptor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">GreeterServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span> <span class="c1">// 业务函数调用
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">{</span>
		<span class="nx">Server</span><span class="p">:</span>     <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">FullMethod</span><span class="p">:</span> <span class="s">&#34;/helloworld.Greeter/SayHello&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">srv</span><span class="p">.(</span><span class="nx">GreeterServer</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">.(</span><span class="o">*</span><span class="nx">HelloRequest</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">interceptor</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后我们再来看启动服务的逻辑，<code>Serve()</code> 的主要逻辑就是一个 for 循环，里面包含错误处理、重试、接受连接、处理连接等逻辑代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// server.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="c1">// 开始接受连接
</span><span class="c1"></span>		<span class="nx">rawConn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>

      <span class="c1">// 为每一个连接启动一个 goroutine 进行处理
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">lis</span><span class="p">.</span><span class="nf">Addr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">rawConn</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对连接请求的处理在 <code>handleRawConn()</code> 函数中，<code>newHTTP2Transport()</code> 的代码主要是一些关于 HTTP2 的赋值和初始化操作，完成 HTTP2 握手阶段。而 <code>serveStreams()</code> 中则主要是调用了<code>HandleStreams()</code> 去真正的接收请求数据流。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// server.go 
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">lisAddr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rawConn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">// 完成 HTTP2 握手
</span><span class="c1"></span>	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newHTTP2Transport</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
	<span class="o">...</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">removeConn</span><span class="p">(</span><span class="nx">lisAddr</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">serveStreams</span><span class="p">(</span><span class="nx">st</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">HandleStreams</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">numServerWorkers</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">handleStream</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">traceInfo</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">stream</span><span class="p">))</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">})</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 <code>HandleStreams()</code> 的实现中前面一大部分是对数据流（Stream）的初始化和数据接收，在数据流接收完毕后，通过传入的 <code>startStream()</code> 来处理数据流。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// internal/transport/handler_server.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ht</span> <span class="o">*</span><span class="nx">serverHandlerTransport</span><span class="p">)</span> <span class="nf">HandleStreams</span><span class="p">(</span><span class="nx">startStream</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Stream</span><span class="p">),</span> <span class="nx">traceCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 省略数据流初始化、数据接收代码
</span><span class="c1"></span>
	<span class="c1">// 处理数据流
</span><span class="c1"></span>	<span class="nf">startStream</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">ht</span><span class="p">.</span><span class="nf">runStream</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">requestOver</span><span class="p">)</span>

	<span class="c1">// 等待数据读取的 goroutine 完成
</span><span class="c1"></span>	<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="o">&lt;-</span><span class="nx">readerDone</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>startStream()</code> 最终调用的是 <code>grpc-go/server.go</code> 中的 <code>handleStream()</code> 方法，该函数内部实现主要是区分出客户端发来的是一元 RPC 请求（UnaryRPC）还是流式 RPC 请求（StreamingRPC），然后根据不同的 RPC 请求类型分别使用 <code>processUnaryRPC()</code> 和<code>processStreamingRPC()</code> 进行处理，这两个处理函数的内部实现基本上就是对数据的接收、编解码（编解码上面有分析最终的调用）等操作，这里不再深入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// server.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">handleStream</span><span class="p">(</span><span class="nx">t</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ServerTransport</span><span class="p">,</span> <span class="nx">stream</span> <span class="o">*</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Stream</span><span class="p">,</span> <span class="nx">trInfo</span> <span class="o">*</span><span class="nx">traceInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">srv</span><span class="p">,</span> <span class="nx">knownService</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">services</span><span class="p">[</span><span class="nx">service</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">knownService</span> <span class="p">{</span>
	   <span class="c1">// 判断是一元 RPC 请求还是流式 RPC 请求
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">processUnaryRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">md</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">streams</span><span class="p">[</span><span class="nx">method</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">processStreamingRPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">stream</span><span class="p">,</span> <span class="nx">srv</span><span class="p">,</span> <span class="nx">sd</span><span class="p">,</span> <span class="nx">trInfo</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>通过对 gRPC 官方 <a href="https://github.com/grpc/grpc-go/tree/344b93a285883f2da713622d5064ad4b4512e63e/examples/helloworld">helloworld</a> 样例的源码分析，我们完成了一个完整 RPC 调用的链路追踪，再回头看看最初的那个 RPC 模型图，是否每个阶段都已经被覆盖。后续如果碰到 gRPC 服务调用方面的故障排查，就可以先定位出是 RPC 调用的哪个阶段出了问题，然后对照该阶段的源码进行具体分析，不至于茫然无措。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">MidoriFizz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-12-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">自顶向下</a>
          <a href="/tags/grpc/">gRPC</a>
          <a href="/tags/rpc/">RPC</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/why-websocket-masked/">
            <span class="next-text nav-default">为什么WebSocket需要数据掩码</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2021-12-28 21:42:38 \u002b0800 CST',
        title: '自顶向下-gRPC调用',
        clientID: '857106e549022fc115bb',
        clientSecret: '8ba8442406bd4acab9bc97c059f393723035540e',
        repo: 'moontalk',
        owner: 'MidoriFizz',
        admin: ['MidoriFizz'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:rickylin7mail@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.facebook.com/" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://github.com/midorifizz" class="iconfont icon-github" title="github"></a>
  <a href="https://blog.moontalk.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    
    
  </div>

  <span class="copyright-year">
    &copy; 
    2020 - 
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">MidoriFizz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.2517c0eb67172a0bae917de4af59b10ca2531411a009d4c0b82f5685259e5771.js"></script>








</body>
</html>
