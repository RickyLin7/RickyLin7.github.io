<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on moontalk</title>
    <link>https://blog.moontalk.top/post/</link>
    <description>Recent content in Posts on moontalk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 28 Feb 2022 09:33:52 +0800</lastBuildDate><atom:link href="https://blog.moontalk.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>谈谈 Kubernetes Operator</title>
      <link>https://blog.moontalk.top/post/crd-and-operator/</link>
      <pubDate>Mon, 28 Feb 2022 09:33:52 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/crd-and-operator/</guid>
      <description>无状态容易，有状态很难 我们都知道，在 kubernetes 环境中部署和管理一个“无状态应用”是非常容易的，比如 web应用、移动后端和 API服务等。只需要使用像 Deployment</description>
    </item>
    
    <item>
      <title>自顶向下-Pod创建</title>
      <link>https://blog.moontalk.top/post/top-down-pod-create/</link>
      <pubDate>Sun, 09 Jan 2022 15:40:22 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/top-down-pod-create/</guid>
      <description>当我们在 kubernetes 集群中部署 nginx 服务时，可能会使用 kubectl apply 命令来应用一份声明式的 YAML 文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion:apps/v1kind:Deploymentmetadata:name:nginx-deploymentspec:selector:matchLabels:app:nginxreplicas:2# tells deployment to run 2 pods matching the templatetemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.14.2ports:- containerPort:80 经过</description>
    </item>
    
    <item>
      <title>自顶向下-gRPC调用</title>
      <link>https://blog.moontalk.top/post/top-down-grpc-call/</link>
      <pubDate>Tue, 28 Dec 2021 21:42:38 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/top-down-grpc-call/</guid>
      <description>RPC RPC（远程服务调用）出现的最初目的，是为了让计算机向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为</description>
    </item>
    
    <item>
      <title>为什么WebSocket需要数据掩码</title>
      <link>https://blog.moontalk.top/post/why-websocket-masked/</link>
      <pubDate>Fri, 17 Sep 2021 16:08:09 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/why-websocket-masked/</guid>
      <description>建立连接 WebSocket 建立连接时复用了 HTTP 的握手通道，整个流程只有以下两步： 客户端通过 HTTP 请求与 WebSocket 服务端协商升级协议。 服务端响应协议升级。 协议升级完成后，双</description>
    </item>
    
    <item>
      <title>为什么需要Pod</title>
      <link>https://blog.moontalk.top/post/why-pod/</link>
      <pubDate>Tue, 07 Sep 2021 19:26:25 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/why-pod/</guid>
      <description>Kubernetes 为什么需要创造一个“Pod容器组”的概念，而不是直接使用容器？ 这个问题想必很多初次接触 Kubernetes 的同学都会存在，我也不例外，当时觉得 Kubernetes 有点故意抬高</description>
    </item>
    
    <item>
      <title>Tornado源码分析(3) - 协程</title>
      <link>https://blog.moontalk.top/post/tornado-code-analysis-3/</link>
      <pubDate>Tue, 27 Jul 2021 19:53:12 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/tornado-code-analysis-3/</guid>
      <description>注：本文所分析 tornado 源码版本为 4.5.3 Future 对象 Future 对象可以简单的理解为一个异步操作的占位符，Future 对象有以下几个特性： 包含了很多属性，包括 _result 和 _ca</description>
    </item>
    
    <item>
      <title>Tornado源码分析(2) - IOLoop</title>
      <link>https://blog.moontalk.top/post/tornado-code-analysis-2/</link>
      <pubDate>Tue, 27 Jul 2021 19:50:11 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/tornado-code-analysis-2/</guid>
      <description>注：本文所分析 tornado 源码版本为 4.5.3 IOLoop 是对IO多路复用的封装，它实现了一个单例，将这个单例保存在 IOLoop._instance 中。 IOLoop 实现了 Reactor 模型，将所有要处理的IO事件注册到一</description>
    </item>
    
    <item>
      <title>Tornado源码分析(1) - Configurable</title>
      <link>https://blog.moontalk.top/post/tornado-code-analysis-1/</link>
      <pubDate>Tue, 27 Jul 2021 19:43:54 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/tornado-code-analysis-1/</guid>
      <description>注：本文所分析 tornado 源码版本为 4.5.3 tornado.ioloop.IOLoop.instance().start()，这是 tornado 框架启动“事件循环”的标</description>
    </item>
    
    <item>
      <title>IO多路复用 - select、poll、epoll</title>
      <link>https://blog.moontalk.top/post/io-multiplexing/</link>
      <pubDate>Tue, 27 Jul 2021 19:37:19 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/io-multiplexing/</guid>
      <description>承接上篇（I/O模式详解），这一节来整理一下关于IO多路复用的相关知识。 select、poll、epoll 都是IO多路复用的机制。IO多路复</description>
    </item>
    
    <item>
      <title>I/O模式详解</title>
      <link>https://blog.moontalk.top/post/io-mode-analysis/</link>
      <pubDate>Tue, 27 Jul 2021 19:28:34 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/io-mode-analysis/</guid>
      <description>用户空间和内核空间 我们知道操作系统采用的是虚拟地址空间，以32位操作系统举例，它的寻址空间为4G(2的32次方)，这里解释二个概念: 寻址：是</description>
    </item>
    
    <item>
      <title>Linux资源隔离与资源限制实验</title>
      <link>https://blog.moontalk.top/post/resource-test/</link>
      <pubDate>Thu, 24 Jun 2021 15:00:26 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/resource-test/</guid>
      <description>环境准备 系统：CentOS7 64位 配置：1核 2G内存 测试 chroot命令 概念： chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目</description>
    </item>
    
    <item>
      <title>从容器到容器云</title>
      <link>https://blog.moontalk.top/post/docker-and-k8s/</link>
      <pubDate>Tue, 22 Jun 2021 21:36:11 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/docker-and-k8s/</guid>
      <description>前言 我认为在学习一门技术以前，首先得去了解一下这项技术的背景和发展史，这对后面理解“为什么这样设计”其实帮助很大。如果开源项目直接拿过来蒙头</description>
    </item>
    
    <item>
      <title>LVS-TUN模式集群防火墙下的调试之旅</title>
      <link>https://blog.moontalk.top/post/lvs-with-firewall/</link>
      <pubDate>Sun, 24 May 2020 21:19:54 +0800</pubDate>
      
      <guid>https://blog.moontalk.top/post/lvs-with-firewall/</guid>
      <description>一、集群说明 OS: CentOS7.2 DS(LVS): 10.1.61.114 LVS-MODE: TUN VIP: 10.1.61.82 RS1(Nginx): 10.1.62.105 RS2(Nginx): 10.1.62.106 PORT: 80 防火墙: DS、RS1、RS2均安装 firewalld，且开放80端口（tcp，udp） 二、预备知识 firewalld</description>
    </item>
    
  </channel>
</rss>
